# Chapter 10. 이벤트

### 이벤트를 왜 사용할까?

- BOUNDED CONTEXT간 강한 결합을 풀기 위해서 사용한다.
- 여기서 강한 결합의 예시
    - 외부 시스템이 망가졌다면 대기 시간이 늘어나 우리 서비스 시간도 늘어난다.
    - 환불 기능이 실패했을 때 주문만 취소 상태로 변경하고 환불만 다시 시도
        - 주문과 환불이 묶여있음

> 비동기 이벤트를 사용하면 해당 이벤트를 실행시키고 끝이다. 환불 기능이 실패했을 때 환불 기능이 실패했다는 이벤트만 보내면 된다.

- 이렇게 비동기 이벤트를 사용하면 시스템 간 결합도를 크게 낮출 수 있다

### 이벤트가 뭔데?

- 이벤트가 발생했다는 건 상태가 변경됐다는 것
- 이벤트가 발생하면 그 이벤트에 반응하여 원하는 동작을 수행하게 할 수 있다
- 이벤트를 실제로 구현할 때 과거에 벌어지고 나서 실행하는 것이기 때문에 과거 시제를 사용해 이름을 작성한다.
    - e.g. 배송지 변경 이벤트 → ShippingInfo**Changed**Event
- 이벤트는 과거에 벌어진 사건이므로 데이터가 변경되지 않는다.
- 이벤트 디스패처의 구현 방식에 따라 이벤트 생성과 처리를 동기나 비동기로 실행한다.

### 이벤트의 흐름

1. 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트 발생
2. 이벤트를 전달해주는 이벤트 디스패처(이벤트 Publisher)에게 전달됨
3. 이벤트를 받아서 주는 이벤트 핸들러(이벤트 Subscriber)에게 전달됨
    1. 필요한 데이터는 여기(이벤트 핸들러)에서 관련 API를 호출하거나 DB에서 직접 읽어서 데이터를 추가한다.

### 이벤트 용도

- 트리거
    - 도메인의 상태가 바뀌면 다른 서비스의 로직을 실행해야 할 때
    - 예를 들어, 주문의 취소하면 환불 서비스에 로직을 날려 환불 처리 로직을 실행
- 데이터 동기화
    - 배송지를 변경하면, 우리 도메인뿐만 아니라 외부 배송 서비스에도 바뀐 배송지 정보를 전송해야된다.

### 이벤트의 장점

- 서로 다른 도메인 로직이 섞이는 걸 방지할 수 있다
    - 주문 취소에 환불 로직이 들어가지 않고 주문 취소 이벤트만 이벤트 디스패처에 보내면 된다
- 즉, 의존을 제거할 수 있으므로 기능 확장도 용이하다.

### 이벤트 구현

- 모든 이벤트가 공통으로 갖는 속성이 존재한다면 관련 상위 클래스를 만들 수도 있다
    - 이벤트 발생시간 등등...
- 이벤트 핸들러를 구현할 때 canHandle()을 추가해 이벤트를 처리할 수 있는지 여부를 검사해줄 수 있다

### 동기 이벤트 구현

- 핸들러 목록을 유지하기 위해 ThreadLocal을 사용할 수 있는데 웹 애플리케이션 서버는 스레드를 재사용하므로 reset해줘야 한다.
    - 매번 reset해줘야 하므로 AOP를 통해 중복을 제거해줄 수 있다

### 비동기 이벤트 구현

- 로컬 핸들러 비동기 실행
    - 별도 스레드를 사용하기 위해 ExcutorService를 사용한다
    - 별도 스레드를 사용하면 같은 트랜잭션 범위에 묶을 수 없기 때문에 한 트랜잭션으로 실행해야 하는 이벤트 핸들러는 비동기로 처리하면 안된다
- 메시지 큐 사용
    - 글로벌 트랜잭션이 필요하다
    - 메시지 큐를 사용하면 이벤트를 발생하는 주체와 이벤트 핸들러가 별도 프로세스(JVM)에서 동작한다.
    - Rabbit MQ는 글로벌 트랜잭션을 지원해서 안전하다. Kafka는 지원하지 않는다. 그런데 Kafka가 더 많이 쓰인다
- 이벤트 저장소와 포워더 사용
    - 이벤트 저장소는 말 그대로 이벤트가 발생하면 저장소에 저장한다.
        - 이벤트는 변경되지 않으므로 이벤트 저장소는 이벤트를 추가하는 기능과 조회하는 기능만 제공한다.
    - 포워더는 이벤트 저장소에 주기적(스케줄링)으로 읽어와서 이벤트 핸들러에 전달해준다.
- 이벤트 저장소와 이벤트 제공 API 사용
    - API를 통해 JSON으로 그 정보를 전달해줄 수 있다.
    - limit과 offset을 지정해서 0개 이벤트를 제공했으면 재시도하도록(똑같은 offset과 limit으로) 만들어줘야 한다.

### 이벤트 구현에 대한 고민

- 전송 실패를 얼마나 허용해야 하나?
    - 실패한 이벤트의 재전송 횟수
- 로컬 핸들러를 이용해서 비동기로 처리할 경우, 이벤트를 유실할 수도 있다
- 이벤트 순서가 다를 수 있다.
- 이벤트 재처리는 어떻게 해야할지?
