# 2장 SQL 튜닝 용어를 직관적으로 이해하기

## 물리 엔진과 오브젝트 용어

### 전체 간단 Flow

1. SQL 문을 실행
2. MySQL 엔진에서 SQL 문법 에러 검사 (**`Parser`** 역할)
    1. SQL문을 트리 최소 단위(`>`, `<`, `=` 등)로 분리해서 트리로 만듦
3. 유효성 검사 (`**Preprocessor**` 역할)
    1. 권한, 테이블, 열 존재여부 등
4. 효율적으로 데이터를 찾아가는 계획 수립 (**`Optimizer`** 역할)
    1. 어떤 순서로 테이블에 접근할 지, 인덱스를 사용할 지 등...
    2. Optimizer의 선택이 항상 최선의 선택은 아님
5. MySQL 엔진 실행기로 **스토리지 엔진**을 통해 데이터를 찾고 MySQL 엔진으로 결과물 반환
6. MySQL 엔진은 불필요한 부분을 **필터링**하고 사용자에게 최종 결과를 알려줌

### DB 엔진

- MySQL 엔진
    - SQL 문법 검사와 SQL 문을 최소 단위로 분리하여 원하는 데이터를 빠르게 찾도록 함
    - 그리고 스토리지 엔진으로부터 받은 데이터들을 가공하고 연산하는 역할을 함
- 스토리지 엔진
    - 디스크나 메모리에 저장된 필요한 DB 데이터를 가져오는 역할
    - 이후 MySQL 엔진으로 보내줌
    - 필요하다면 외부 스토리지 엔진을 바꿔서 사용할 수 있음
    - 보통 OLTP(Online Transaction Processing) 환경이 대다수인 만큼 InnoDB를 사용함
        - InnoDB → 트랜잭션 제공, row 단위 락, 장애 복구 기능 등...
        - MyISAM → 기능이 없고 빠름. 트랜잭션 X, 테이블 단위로만 락
        - Memory → 데이터가 유실될 위험이 있어 빠른 처리가 필요할 때만 사용, 조회할 때만

### DB 오브젝트

- 테이블
- 컬럼, 로우
- 기본 키
    - MySQL에선 클러스터형 인덱스로 작동
    - 클러스터형 인덱스 : 생성될 때 정렬된 채로 들어간다. 그래서 페이지 단위로 디스크에 들어갈 때도 정렬돼서 들어가기 때문에 성능 상 더 좋다.
- 외래 키
    - 변경 사항이 발생할 때마다 항상 검증
    - 정합성 높일 때 좋음
- 인덱스
    - UNIQUE INDEX
        - 데이터가 유일해야함
        - null을 입력할 수 있음(기본 키와 차이)
        - 중복 체크를 함
    - INDEX
        - 신규 데이터가 입력되더라도 중복 체크를 안함
- 뷰
    - 가상 테이블
    - 테이블에서 제한된 정보만 제공하기에 안전하게 운영가능
    - 사실상 잘 안씀. 조회용 쿼리를 관리하는 주체가 DBA가 될 수도 있기 때문?

## 논리적인 SQL 개념 용어

### 서브쿼리 위치에 따른 SQL 용어

```java
SELECT (SELECT FROM) -> 스칼라 서브 쿼리
FROM (SELECT FROM) -> 인라인 뷰
WHERE col1 IN (SELECT FROM) -> 중첩 서브 쿼리
```

- 스칼라 서브 쿼리는 1행 1열 구조로 출력되어야 한다. 그래서 `MAX`, `COUNT`, `SUM` 등이 많이 쓰인다.
- 인라인 뷰는 FROM에서 일시적으로 뷰를 생성한다는 의미다. 내부적으로 메모리 또는 임시 테이블을 생성하여 활용한다.
- 메인 쿼리 = 외부 쿼리, 서브 커리 = 내부 쿼리
- 연관되어있는 데이터에 따라서(서브쿼리에서 메인 쿼리 테이블에 있는 걸 이용한다든지... Student.age 등...) 서브 쿼리가 먼저 실행될 수도 있고, 메인 쿼리가 먼저 실행될 수도 있다
    - 메인쿼리가 먼저 실행되는 상관 서브쿼리는 스칼라, 중첩 서브 쿼리에서 발생한다.

### 반환 결과에 따른 SQL 용어

- 서브쿼리를 사용한다면 반환 결과가 중요해진다
- 단일행, 다중행, 다중열의 경우가 있다
    - 단일행 서브쿼리는 메인 쿼리보다 먼저 호출된다.

> 서브 쿼리는 아래 같은 경우 많이 쓴다. (JOIN으로 해결 안되는 경우)

```sql
SELECT city, sum_price
FROM
(
SELECT city, SUM(price) AS sum_price FROM sale
GROUP BY city
) AS s
WHERE sum_price < 2100;
```

# 2장 - 2 조인

> 조인 : 필요한 데이터를 결합하는 방식

![스크린샷 2021-08-29 오전 1.35.34.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/85ad9a26-a500-45b6-9143-0b9cd174b995/스크린샷_2021-08-29_오전_1.35.34.png)

- inner join
    - 양 쪽 모두 존재하는 데이터만 조인
- left outer join
    - 왼쪽 테이블 (먼저 작성된 테이블) 기준으로 조인을 수행
    - 조인 조건과 일치하지 않더라도 왼쪽 테이블은 결과에 포함됨
        - Null로 포함
- right outer join
    - 오른쪽 테이블 (먼저 작성된 테이블) 기준으로 조인을 수행
    - 조인 조건과 일치하지 않더라도 오른쪽 테이블은 결과에 포함됨
- full outer join
    - mysql에는 없음

> SQL을 작성할 때 왼쪽 테이블을 먼저 적기 때문에 왼쪽이 기준이 되는 Left Join을 많이 씀

- cross join
    - 조인에 참여하는 테이블에서 발생할 수 있는 모든 조합을 찾아내서 반환함
    - 그만큼 다른 JOIN보다 시간적, 공간적 리소스를 많이 잡아먹음

![스크린샷 2021-08-29 오전 1.40.53.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cbce5dbb-6175-40a2-b6e1-22fc3300d85d/스크린샷_2021-08-29_오전_1.40.53.png)

- natural join
    - 조인 조건절을 작성하지 않아도 자동으로 조인을 수행
    - 제대로 조인되면 inner join과 같은 효과
    - 동일한 열이 없다면 자동으로 cross join을 해버림

## 조인 알고리즘 용어

- 먼저 접근하는 테이블 = 드라이빙 테이블 = 외부 테이블
- 이후에 접근하는 테이블 = 드리븐 테이블 = 내부 테이블

> 가능하면 적은 결과를 반환하는 드라이빙 테이블을 선정하고, 조인 조건이 인덱스로 설정되도록 해야한다.

### **중첩 루프 조인(nested loop join, NL Join)**

- 드라이빙 테이블의 데이터 1건당 드리븐 테이블을 반복해 검색
    - 기본키와 인덱스가 없는 두 테이블이랑면 중첩 for 문 로직과 똑같이 동작
- 인덱스가 있다면 정렬되어있으므로 중첩 for 문이 아닌 매우 적은 시간 안에 동작

    ![스크린샷 2021-08-29 오전 1.45.09.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e1e37ffd-17b3-4ac6-b343-5ff492af42f5/스크린샷_2021-08-29_오전_1.45.09.png)

> 인덱스가 있다면 열 기준으로 순차 정렬되나, 인덱스를 이용해 테이블의 데이터를 찾아가는 과정에서 임의 접근 방식인 랜덤 액세스가 발생한다. 랜덤 액세스를 줄여야 성능이 향상된다

### 블록 중첩 루프 조인(block nested loop join, BNL Join)

- 조인 버퍼(join buffer)라는 개념을 도입해서 조인 성능의 향상을 꾀함
- 드라이빙 테이블의 결과를 조인 버퍼에 넣어놓은 후, 조인 버퍼에서 드리븐 테이블의 데이터와 맞는지 찾음
- 즉, 중첩 for문이 아니라 for문이 2번 돈다

![스크린샷 2021-08-29 오전 1.57.46.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1e0df14e-5a64-49cc-95db-2e6e5970e4c1/스크린샷_2021-08-29_오전_1.57.46.png)

### 블록 해시 조인(block hash join)

- BNL Join과 비슷한 방법
- 조인 버퍼에 해시 값을 적용한 것

### 배치 키 액세스 조인(Batched Key Access Join, BKA Join)

- 접근할 데이터를 미리 예상하는 알고리즘을 적용시킨 조인
- 조인 버퍼와 랜덤 버퍼를 사용한다.
- 랜덤 버퍼에 들어갈 때 MMR 기능이 수행된다

> MRR(Multi Range Read) : 드리븐 테이블의 데이터를 예측하고 정렬된 상태로 버퍼에 적재하는 기능

- MRR 기능, 즉 미리 예측된 데이터를 가져와 정렬된 상태에서 랜덤 버퍼에 담기 때문에 랜덤 액세스가 아닌 시퀀셜 액세스를 수행한다.
- 즉, 랜덤 액세스된 것까지 정렬해서 다시 버퍼에 담는 방식

![스크린샷 2021-08-29 오전 2.06.47.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3db4796e-d7cb-46e1-9149-e4d82c1aaf92/스크린샷_2021-08-29_오전_2.06.47.png)

### 해시 조인

- 조인에 참여하는 각 테이블의 데이터를 내부적으로 해시값을 만들어 내부 조인을 수행
    - 해시값이라 동등 조건에 매우 유리
- 내부 조인을 수행한 결과는 조인 버퍼에 저장된다
- 데이터가 해시가 되므로 인덱스가 필수가 아니다.

![스크린샷 2021-08-29 오전 2.13.50.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/32efe98f-1a6c-4fd3-9a03-2328e0262983/스크린샷_2021-08-29_오전_2.13.50.png)

> 정렬과 버퍼의 중요성!

## 튜닝 용어 - 스캔 방식

### 테이블 풀 스캔(Table Full Scan)

- 인덱스를 거치지 않고 처음부터 끝까지 데이터를 찾는 방식
- where 절을 기준으로 인덱스가 없거나 대량의 데이터가 필요할 때 수행하게 된다
- 성능 측면에서는 처음부터 끝까지 다 스캔하므로 보통 부정적이며 인덱스 없이 사용하는 유일한 방식

![스크린샷 2021-08-29 오후 1.10.02.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/435b687e-e7f5-436d-b930-31e2150c34e0/스크린샷_2021-08-29_오후_1.10.02.png)

> 선택도가 20%가 넘게 select되면 인덱스는 소용이 없다. 풀 테이블 스캔이 더 낫다

### 인덱스 범위 스캔(Index Range Scan)

- 말 그대로 인덱스 **범위**로 스캔하고 그 범위만 데이터를 찾는 방식
- BETWEEN, <, >, LIKE 등 비교 연산 및 구문에 포함될 경우, 인덱스 범위 스캔으로 수행
    - SQL문만 봐도 **범위**라는 걸 알 수 있다
    - like를 쓸 때 %가 앞에 붙으면 인덱스를 타지 않는다
- 좁은 범위를 스캔할 때는 성능적으로 매우 효율적이나 넓은 범위를 스캔할 때는 비효율적

![스크린샷 2021-08-29 오후 1.37.58.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1cc9eb88-98e6-4a01-8367-066712f00d3a/스크린샷_2021-08-29_오후_1.37.58.png)

![스크린샷 2021-08-29 오후 1.35.31.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/19f18152-9b67-4cfc-82c7-1b582fc28235/스크린샷_2021-08-29_오후_1.35.31.png)

![스크린샷 2021-08-29 오후 1.36.46.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c4feb57d-9051-4c8c-ab90-1e97689ff233/스크린샷_2021-08-29_오후_1.36.46.png)

### 인덱스 풀 스캔(Index Full Scan)

- 테이블에서 데이터를 찾지 않고 **인덱스 테이블을** 처음부터 끝까지 찾는 방식
- 그래서 인덱스로 구성된 열 정보만 요구하는 SQL문에서 실행된다
- 인덱스는 테이블보다 상대적으로 적으므로 테이블 풀 스캔 방식보다 인덱스 풀 스캔 방식이 성능상 더 낫다

![스크린샷 2021-08-29 오후 1.37.01.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ed2f6eff-ddb2-458d-8174-eda77392029e/스크린샷_2021-08-29_오후_1.37.01.png)

### 인덱스 고유 스캔(Index Unique Scan)

- 기본 키나 고유 인덱스로 테이블의 데이터를 찾는 방식
- 유일하므로 가장 효율적이다
- WHERE절에 = 조건이 있을 때 실행된다

![스크린샷 2021-08-29 오후 1.36.29.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de8b86f8-aabf-4bfd-8bde-9907754c2411/스크린샷_2021-08-29_오후_1.36.29.png)

### 인덱스 루스 스캔(Index Loose Scan)

- 인덱스의 필요한 부분들만 골라서 스캔하는 방식
- WHERE절, GROUP BY, MAX, MIN 함수가 포함되면 작동한다
    - 인덱스를 사용했으니 정렬이 되어있고 맨 위나 맨 아래만 찾아보면 되므로 필요한 부분만 스캔
- 범위 스캔이 아니다.

### 인덱스 병합 스캔(Index Merge Scan)

- 테이블 내에 생성된 인덱스를 통합해서 스캔하는 방식
- 서로 다른 인덱스로 존재하기 때문에 통합하게 되며 통합하는 방법으로는 결합(Union)과 교차(intersection)가 있다
- 개별 인덱스를 각각 수행하고 또 합쳐야 하므로 시간이 몇 배로 걸린다

## 튜닝 용어 - 디스크 접근 방식

> 페이지(Page) : 데이터를 검색하는 최소 단위, 페이지 단위로 읽고 쓰기를 행할 수 있다

### 시퀀셜 액세스

- 물리적으로 인접한 페이지를 차례대로 읽는 순차 접근 방식
- 디스크 헤더의 움직임을 최소화할 수 있다 (불필요하게 왔다리 갔다리 하지 않는다)
- 테이블 풀 스캔일 때는 인접한 페이지를 여러 개 읽는 다중 페이지 읽기 방식으로 수행한다

### 랜덤 액세스

- 물리적으로 떨어진 페이지에 임의로 접근하는 방식
- 순서없이 이동하는 만큼 물리적인 움직임이 필요하기 때문에 시간이 오래 걸린다 (불필요하게 왔다리 갔다리한다)

### 액세스 조건

- 디스크에 있는 데이터를 어떻게 접근할 것인지 다루는 조건
- 인덱스가 있는 열을 먼저 WHERE절에 쓰자!
- 예를 들어, ID에 인덱스가 있다면 이렇게 인덱스가 없는 CODE보다 먼저 쓰자.
    - `SELECT * FROM TABLE WHERE ID = 1 AND CODE = 'A';`

### 필터 조건

- 액세스 조건으로 가져온 데이터를 대상으로 필터 조건를 적용해 필터링 작업을 한다.
- 필터링할 데이터가 없을수록 좋은 SQL 문 (당연함)
    - 데이터를 가져와서 필터링하게 된다. 그래서 액세스 조건이 중요하다
- 여기서 CODE = 'A' 부분
    - `SELECT * FROM TABLE WHERE ID = 1 AND CODE = 'A';`
    - ID = 1에서 인덱스를 통해 가져오고, CODE = 'A'에서 필터링을 한다.

## 튜닝 용어 - 응용

### 선택도

- WHERE 절 조건문에 따라 선택되는 데이터 비율
- 선택도가 높으면 해당 열에 중복되는 데이터가 많고 선택도가 낮으면 열에 중복되는 데이터가 적다는 뜻
- 선택도가 낮을수록 많은 데이터에서 원하는 데이터만 골랐다는 뜻이므로 낮은 선택도가 더 좋은 의미
- `선택도 = 선택한 데이터 수 / 전체 데이터 수` → `변형된 선택도 = 1 / DISTINCT(COUNT 해당 조건 열)`
    - 조건 절의 데이터 수를 매번 계산할 수 없고 insert, update등 여러 변형이 일어나므로 중복을 제거한 변형된 선택도를 가지고 계산한다.

### 카디널리티

- 출력될 것이라 예상되는 데이터 수
- 현업에서는 전체 행에 대한 특정 열의 중복 수치를 나타내는 지표로 자주 활용함
- `카디널리티 = 전체 데이터 건 수 * 선택도`
- 특정 열에 중복된 데이터가 많다면 카디널리티가 낮고, 중복된 데이터가 적다면 카디널리티가 높다
- 카디널리티가 낮은 데이터를 조회하면 대량의 데이터가 출력된다 (중복된 데이터가 많으니까)
- 선택도와 카디널리티는 반비례한다
- 예를 들어, 주민등록번호는 유일하므로 카디널리티가 높고, 성별은 카디널리티가 낮다. 이름은 적절히 섞여있으니 중간이라고 말할 수 있겠다

### 힌트

- 말 그대로 우리가 옵티마이저에게 힌트를 줄 수 있다 (우리가 아는 지름길을 옵티마이저에게 알려준다)
- 하지만 옵티마이저는 자신이 더 똑똑한 걸 아는지 우리가 준 힌트를 무조건 참고하진 않는다. 무시될 수 있다
- 쓰는 방법 : `SELECT * FROM 학생 USE INDEX(학생_IDX) WHERE 이름 = ?`
    - 이렇게 문자열로 들어가는 만큼, 학생_IDX를 쓴다고 해놓고 학생_IDX 인덱스를 삭제하면 오류가 뜬다.
    - 그래서 인덱스를 삭제하면 USE INDEX에서 쓰이는 곳은 없는지 확인해보자.
- 자주 쓰이는 힌트
    - STRAGIT_JOIN
        - FROM 절에 작성된 테이블 순으로 조인을 유도함
        - 잘 쓰임
    - USE INDEX
        - 특정 인덱스를 사용하도록 유도함
        - 잘 쓰임
    - FORCE INDEX
        - 특정 인덱스를 사용하도록 강하게 유도함
    - IGNORE INDEX
        - 특정 인덱스를 사용하지 못하도록 유도함

### 콜레이션

- 특정 문자셋으로 DB에 저장된 값을 정렬하는 작업의 규칙
- DB 단위, 테이블 단위, 열 단위까지 세세하게 설정해줄 수 있다
- 예를 들어, `utf8_bin`과 `utf8_general_ci` 콜레이션의 알파벳 정렬 순서는 다르다
    - `utf8_bin`
        - A, B, a, b 순으로 큼
    - `utf8_general_ci`
        - A, a, B, b 순으로 큼

> 참고로 캐릭터셋은 데이터 **저장 셋**이고 콜레이션은 데이터 **정렬 셋**이다
보통 캐릭터 셋과 콜레이션 모두 이모지를 사용할 수 있는 캐릭터셋 : `utf8mb4`, 콜레이션 : `utf8_bin`으로 사용하는 것 같다

```sql
CREATE TABLE t1 ( ... )
CHARACTER SET latin1 COLLATE latin1_danish_ci;

# ALTER도 가능!
```

### 통계정보 - 히스토그램

- 옵티마이저는 통계정보에 기반을 두고 SQL 문의 실행 계획을 수립한다
- MySQL은 시스템 변수를 통해 활용할 통계정보의 수준을 정의할 수 있다
    - 테이블, 인덱스, 열 통계정보를 통해 어떤 것을 선택할 지 결정한다.
- 히스토그램
    - 테이블의 열값이 어떻게 분포되어있는지를 확인하는 통계정보
    - 중복이 제거된 열의 개수(`COUNT(DISTINCT 열)`)로 열값의 분포를 예측한다
    - MySQL에서 열의 분포를 저장할 때 높이 균형 히스토그램을 사용하며 동일한 개수로 열들을 그룹화하고 버킷만큼 분리해서 최댓값 데이터를 저장한다
    - 버킷에는 최댓값만 저장한다
    - `ANALYZE TABLE 사원 UPDATE HISTOGRAM ON 이름;` 로 히스토그램 직접 생성
    - `SELECT * FROM INFORMATION_SCHEMA.COLUMN_STATISTICS;` 로 확인

![스크린샷 2021-08-29 오후 3.07.39.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/953f4032-195e-4822-9fb0-d6f1d961f162/스크린샷_2021-08-29_오후_3.07.39.png)

> 6개씩 그룹핑되고(values), 버킷에는 최댓값만 저장된다. (endpoint_value)

- 위 사진에서 `col1 BETWEEN 8 AND 12` 라면 전체 데이터 대비 50%이상의 영역을 스캔해야 하므로 테이블 풀 스캔으로 쿼리가 실행된다.

### 출처

- [https://thecrunchy.tistory.com/35](https://thecrunchy.tistory.com/35)
- [https://www.w3resource.com/sql/joins/cross-join.php](https://www.w3resource.com/sql/joins/cross-join.php)
- [https://mozi.tistory.com/168](https://mozi.tistory.com/168)
- [https://hoing.io/archives/24491](https://hoing.io/archives/24491)
- [https://mozi.tistory.com/222](https://mozi.tistory.com/222)
- [https://dba.stackexchange.com/questions/74261/optimize-the-query-with-big-and-low-cardinality](https://dba.stackexchange.com/questions/74261/optimize-the-query-with-big-and-low-cardinality)
- [https://myjamong.tistory.com/237](https://myjamong.tistory.com/237)
- [https://riverandeye.tistory.com/entry/4-인덱스-확장기능-사용법](https://riverandeye.tistory.com/entry/4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%ED%99%95%EC%9E%A5%EA%B8%B0%EB%8A%A5-%EC%82%AC%EC%9A%A9%EB%B2%95)
- [http://egloos.zum.com/hanulnun/v/2758592](http://egloos.zum.com/hanulnun/v/2758592)
- [http://ojc.asia/bbs/board.php?bo_table=LecOracle&wr_id=227](http://ojc.asia/bbs/board.php?bo_table=LecOracle&wr_id=227)
- [https://sungwookkang.com/1341](https://sungwookkang.com/1341)
