# 3장 - 실행 계획

- mysql -u root -p < hello.sql 을 하면 hello.sql을 실행시킨다.
- 실행계획은 EXPLAIN, DESCRIBE, DESC가 있다
    - 결과는 모두 같음

- id
    - 작을수록 먼저 수행한 값
    - 같은 값이면 조인
- select_type
    - 서브쿼리인지, UNION에 묶인 얘인지 등...
    - SIMPLE : 내부쿼리나 UNION이 아닌 경우, 말 그대로 단순
    - PRIMARY : 첫 번째 SELECT 문에 해당하는 구문, 서브쿼리를 감싸는 외부 쿼리 혹은 UNION 했을 때 처음 SELECT
    - SUBQUERY : 독립적으로 수행되는 서브쿼리
    - DERIVED : FROM 절에 작성된 서브쿼리
    - UNION : UNION 및 UNION ALL 구문으로 합쳐진 SELECT에서 첫 번째를 제외한 SELECT 문
    - UNION RESULT : UNION ALL이 아닌 UNION 구문으로 SELECT 절을 결합했을 때 출력
    - DEPENDENT SUBQUERY : UNION 또는 UNION ALL을 사용하는 서브 쿼리가 메인 테이블의 영향을 받는 경우, 첫 번째 단위 쿼리
        - SQL 튜닝 대상
    - DEPENDENT UNION : UNION 또는 UNION ALL을 사용하는 서브 쿼리가 메인 테이블의 영향을 받는 경우, 두 번째 이후 단위 쿼리
        - SQL 튜닝 대상
    - UNCACHEABLE SUBQUERY : 서브쿼리가 메모리에 상주하지 못해 재활용되지 못할 때. 서브 쿼리 안에 사용자 변수나 RAND() 같은 함수가 포함되는 경우.
        - 매번 값이 달라져서 메모리에 상주하지 못한다
    - MATERIALIZED : IN 절에 서브 쿼리를 임시 테이블로 만들어서 조인 작업을 수행할 때
- table
    - 말 그대로 테이블. 서브 쿼리나 임시 테이블을 만들어서 별도의 작업을 수행할 때는 <subquery#> 이런 식으로 나옴
- partitions
    - 데이터가 저장되는 논리적인 영역
    - 모든 파티션이 아닌 특정 파티션에 선택적으로 접근하는 것이 유리
- type
    - 테이블의 데이터를 어떻게 찾을지. 처음부터 끝까지? or 인덱스 등등...
    - system : 테이블에 데이터가 없거나 한 개만 있는 경우. 성능상 가장 좋음
    - const : 조회되는 데이터가 1건일 때. 성능상 매우 좋음. 고유 인덱스나 기본키 등...
    - eq_ref : 조인이 수행될 때 고유 인덱스 or 기본 키로 단 1건의 데이터를 조회하는 방식. 조인할 때 가장 좋은 방식
    - ref : 조인을 수행할 때 드리븐 테이블의 데이터 접근 범위가 2개 이상일 때
        - 데이터가 많다면 데이터 범위가 많아져서 성능 저하가 일어날 수 있음. =, <, >를 사용해도 그럼
        - 예를 들어, 하나의 사원 번호당 여러 개의 직급
    - ref_or_null : IS NULL 구문에 인덱스를 활용하도록 최적화된 방식
        - NULL은 가장 앞 쪽에 정렬된다. NULL이 적으면 ref_of_null 방식을 사용.
        - NULL이 많으면 튜닝 대상.
    - range : 테이블 내의 연속된 데이터 범위를 조회
        - =, <>, >, IS NULL, BETWEEN, IN 등 범위 스캔
        - 넓으면 튜닝 대상
    - fulltext : full text index를 사용해 접근
    - index_merge : 인덱스가 결합될 때. 전문 인덱스는 제외
    - index : 인덱스 풀 스캔. 테이블 풀 스캔과 유사. 인덱스는 테이블보다 크기가 작으므로 테이블 풀 스캔보다는 빠름
    - ALL : 테이블 풀 스캔
        - 전체 데이터 중 10~20% 이상 조회할 때는 ALL이 더 성능상 유리할 수 있음
- possible_keys
    - 최적화할 수 있는 인덱스 후보군의 목록 출력
- key
    - 사용한 PK 또는 인덱스명
    - 인덱스를 사용하지 않았다면 튜닝의 대상이 됨
- key_len
    - 사용한 인덱스의 바이트 수
    - INT : 4바이트, VARCHAR : 3바이트
- ref : 어떤 조건으로 해당 테이블에 액세스 됐는지
- rows : 데이터의 모든 행 수
    - 예상 값이라 정확하지 않음
    - 최종 건 수와 rows 수가 크게 차이나면 불필요하게 MySQL 엔진까지 데이터를 많이 가져왔다는 뜻이므로 튜닝의 대상이 될 수 있음
- filtered
    - 필터 조건에 따라 어느정도 비율로 필터링 됐는지. 비율로 나타냄
    - 100건에서 10건이면 10(%)이라는 정보 출력
    - MySQL 엔진에서 100건 가지고 있음
    - 높을 수록 좋은 것. 스토리지엔진에서 필터링했을 때 비율을 나타낸 것. 즉, 스토리지 엔진에서 최대한 많이 필터링해야 나중에 나와서 필터링할 필요가 없는 것.
- extra
    - SQL문을 어떻게 수행할 것인지 추가 정보를 보여줌
    - Using temporary가 있으면 정렬 작업을 수행하거나 중복을 제거하는 등 작업을 수행. 이게 메모리에 생성되기 때문에 있으면 SQL 튜닝을 고려해봐야 함
    - Using filesort : 정렬이 필요한 데이터를 메모리에 올리고 정렬함. 이미 정렬된 인덱스를 사용하면 그럴 필요 없지만... SQL 튜닝 검토 대상
    - Not Exists : left join같은 거 할 때 존재하지 않는 데이터 검색할 때

- EXPLAIN FORMAT = TRADITIONAL
- EXPLAIN FORMAT = TREE
- EXPLAIN FORMAT = JSON
- 등 포맷을 지정해줄 수 있음.

### 프로파일링

- 느린 쿼리나 문제가 있다고 의심되는 SQL 찾기
- 기본적으로 OFF되어있음
    - 켜기 : `set profiling = 'ON'`
- 상세 내용은 show profile for query 1 이런식으로 쿼리 ID를 입력해주면 됨.
- 어디서 duration 값이 높은지 파악 가능
