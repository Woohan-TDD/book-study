# 4장 - 악성 SQL 튜닝으로 초보자 탈출하기

## 살펴봐야 하는 것

- 테이블의 데이터 건 수
- 결과 및 소요시간 확인
- 조인, 서브쿼리 구조
- 동등, 범위 조건
- 인덱스 현황
- 데이터 변경 추이
- 실행 계획 등

## 튜닝할 때 알아야 할 지식 (꼭 알아놓기!)

- 기본 키라도 `substring`같은 **함수로 가공**해버리면 기본 키를 인덱스로 사용하지 않는다. 함수로 가공하면 인덱스를 사용하지 않아 스캔 방식이 테이블 풀 스캔이 되어버릴 수 있다. 인덱스가 있는 컬럼은 함수로 가공하지 말자.
- 해당 칼럼이 `not null`이라면 `ifnull` 같은 `null` 입력 방어 로직은 작성하지 말자
- `char(1)` 인데 `int`형인 `1`로 쓰지 말자. 묵시적 형변환이 발생하면 인덱스를 제대로 활용하지 못하게 되고 전체 데이터를 스캔하게 된다
- 열끼리 `concat`해서 `where`절을 쓰지 말자. 테이블 풀 스캔이 일어난다. 각 열끼리 조회하자.
- `distinct`는 중복제거를 하고 정렬 작업도 포함된다. 그리고 이를 위해 임시 테이블을 만들어버린다. 기본 키가 있으면 중복 데이터가 없다는 뜻이니 `distinct`를 쓰지 말자
- 중복 제거가 포함된 `UNION` 보다는 `UNION ALL`을 쓰자
- 인덱스를 고려해서 조건 열을 달자. 인덱스가 `I_A_B_INDEX` 로 `A`열과 `B`열 인덱스를 가지고 있다는 건 `A`열로 정렬된 다음 B로 정렬된 인덱스를 가지고 있다는 뜻이다. `group by`를 할 때 `A, B` 순서로 하자!
    - 그리고 입사일자 인덱스를 사용하지 않고 PK 인덱스를 사용하는 경우가 있으니 이 때는 `USE INDEX`를 사용하자!
- like를 부등호로 바꾸는 시도를 해보자. 범위 인덱스로 검색하도록! 커버링 인덱스 스캔!
    - `날짜 like '1990%'` → `날짜 ≥ '1990-01-01' and 날짜 ≤ '1991-01-01'` 이런 식으로!
    - datetime에 like를 쓰면 형변환이 일어난다?
- 대량의 데이터에는 인덱스 스캔이 오히려 안 좋을 수 있다. `IGNORE INDEX`로 인덱스를 무시하게 하고 풀 테이플 스캔을 하자.
- 인덱스를 너무 자주 사용하면 랜덤 엑세스의 부하가 발생할 수 있다. `입사일자와 '1990-01-01'`을 비교할 지 `YEAR(입사일자)와 '1990'`을 비교할 지 고민해보자
- 데이터가 많은 테이블이 뒤에 가서 조인하게 되면 랜덤 엑세스하게 되면서 비효율적으로 변한다. `from 데이터가 많은 테이블, 데이터가 적은 테이블`으로 적고 돌려도 옵티마이저가 그대로 조인하지 않을 수 있다. 이런 경우에는 `from` 절에 나온 순서대로 돌리도록 `straight_join`을 사용하면 된다
- 서브 쿼리보다는 조인으로 수행하자. ( + `group by`, `having` 사용)
- 존재 여부만 알면 되는 건 `EXISTS`를 활용하자
