# 6장 응용 서비스와 표현 영역

# 표현 영역과 응용 영역

- 응용 영역과 표현 영역이 사용자와 도메인을 연결해주는 매개체 역할을 한다.

## 표현 영역

- 사용자의 요청을 해석한다.
    - 요청: URL, 요청 파라미터, 쿠키, 헤더 등
- 사용자가 어떤 기능을 실행하고 싶어 하는지 판별하고, 그 기능을 제공하는 응용 서비스를 실행한다.
- 응용 서비스의 메서드가 요구하는 파라미터와 표현 영역이 사용자로부터 전달받은 데이터의 형식이 일치하지 않기 때문에 표현 영역은 응용 서비스가 요구하는 형식으로 사용자 요청을 변환한다.
- 응용 서비스의 반환값을 받아 사용자에 알맞은 형식으로 응답한다.
    - e.g. html, json, xml...

## 응용 영역

- 실제 사용자가 원하는 기능을 제공한다.
- 기능을 실행하는데 필요한 입력값을 메서드 파라미터로 전달받고, 처리 결과를 리턴한다.
- 사용자와의 상호작용은 표현 영역이 처리하기 때문에 응용 서비스는 표현 영역에 의존하지 않는다.
    - 링크: 2. Controller와 Service 레이어의 강한 결합 참조

    [잊을만 하면 돌아오는 정산 신병들 | 우아한형제들 기술블로그](https://techblog.woowahan.com/2711/)

# 응용 서비스의 역할

- 클라이언트가 요청한 기능을 실행한다.
- 리포지터리로부터 도메인 객체를 구하고, 도메인 객체를 사용한다.
- 도메인 영역과 표현 영역을 연결해주는 창구인 파사드 역할을 한다.
- 주로 도메인 객체간의 흐름을 제어한다.
    - 리파지토리 메서드 호출 → 도메인 가져옴 → 도메인 메서드 호출
- 데이터 일관성을 보장하기 위해 도메인의 상태 변경을 트랜잭션으로 처리한다.

## 도메인 로직 넣지 않기

- 도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생한다.
    - 코드의 응집성이 떨어진다.
        - 도메인 로직을 파악하기 위해 여러 영역을 분석해야 한다.
    - 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다.
        - 응용 서비스에 별도의 보조 클래스를 만들고 사용할 수도 있지만, 애초에 도메인 영역에 구현했으면 도메인 로직을 위한 별도 클래스를 만들 필요가 없게 된다.
- 소프트웨어의 가치를 높이기 위해서 도메인 로직을 도메인 영역에 모아서 코드 중복이 발생하지 않도록 하고 응집도를 높여야 한다.

# 응용 서비스의 구현

## 응용 서비스의 크기

e.g. 회원 기능 구현하기

- 기능: 가입하기, 탈퇴하기, 암호 변경하기, 비밀번호 초기화하기

### 한 응용 서비스에 회원 도메인의 모든 기능을 구현

**장점**

- 한 도메인과 관련된 기능을 한 클래스에 위치시킴으로써 동일 로직에 대한 중복을 제거할 수 있다.
- e.g. 탈퇴, 암호 변경, 비밀번호 초기화는 모두 대상이 되는 회원이 존재해야 한다.
    - findExistingMember라는 private 메서드를 만들어 재활용 할 수 있다.

**단점**

- 한 서비스 클래스의 크기가 커져서 연관성이 적은 코드가 한 클래스에 함께 위치할 가능성이 높아진다.
    - 관련 없는 코드가 뒤섞여서 코드를 이해하는 데 방해가 될 수 있다.
- 한 클래스에 코드가 모이기 시작하면 엄연히 분리하는 것이 좋은 상황임에도 습관적으로 기존에 존재하는 클래스에 억지로 끼워 넣게 된다.

### 각 구분되는 기능별로 응용 서비스 클래스를 따로 구현

**장점**

- 한 클래스에 관련 기능을 모두 구현하는 것과 비교하여 코드 품질을 일정 수준으로 유지하는 데 도움이 된다.
- 클래스별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않는다.

**단점**

- 각 기능마다 동일한 로직을 구현할 경우 여러 클래스에 중복해서 동일한 코드를 구현할 가능성이 있다.
    - 이러한 경우에는 별도 클래스에 로직을 구현하여 코드가 중복되는 것을 방지할 수 있다.

## 응용 서비스의 인터페이스와 클래스

- 또다시 인용... 이 파트 설명하는데 이만한 글이 없다.

    [안정된 의존관계 원칙과 안정된 추상화 원칙에 대하여 | 우아한형제들 기술블로그](https://techblog.woowahan.com/2561/)

- 인터페이스가 필요한 상황
    - 구현 클래스가 여러개인 경우 → 런타임에 구현체를 교체해야 할 경우
    - 응용 서비스는 런타임에 교체하는 경우가 거의 없고, 한 응용 클래스의 구현 클래스가 두개인 경우도 드물다. 이러한 영역에 인터페이스를 추출하면 복잡도만 높아진다.
    - 인터페이스가 명확하게 필요하기 전까지 응용 서비스에 대한 인터페이스를 작성하는 것이 좋은 설계라고 볼 수 없다.
    - TDD로 구현하면 구현체가 없어 Fake 객체를 만들기 위해 인터페이스를 추출할 수도 있을 것이다. Mockito와 같은 라이브러리를 이용하면 인터페이스 없이 테스트용 mock 객체를 만들 수 있으므로 인터페이스를 추출하지 않아도 된다.

## 메서드 파라미터와 값 리턴

- 값 전달을 위한 DTO를 만들어 전달받을 수 있다.
- 스프링 MVC와 같은 프레임워크는 웹 요청 파라미터를 자바 객체로 변환해주는 기능을 제공한다.
- 표현 영역에서 응용 서비스의 결과가 필요하다면 응용 서비스에서 메서드 호출 결과로 리턴한다.
- 응용 서비스에서 애그리거트 객체를 그대로 리턴할 수도 있다.
    - 도메인 로직 실행을 표현 영역에서 할 수 있는 여지를 주므로 응집도가 떨어질 수 있다.
    - 필요한 데이터만 dto로 내려주는 편이 낫다.

## 표현 영역에 의존하지 않기

- 표현 영역의 구현 기술을 서비스 내에서 사용하지 말자.
- 응용 서비스에서 HttpServeletRequest, HttpSession과 같은 표현영역의 타입을 그대로 넘기면 안된다.
- 표현 영역에 대한 의존이 발생하면 응용 서비스만 단독으로 테스트하기 어려워진다.
- 응용 서비스가 표현 영역의 역할까지 대신하여 응집도가 깨질 수 있다.

## 트랜잭션 처리

- 일관성 있는 동작을 위한 응용 서비스의 중요한 역할이다.
- 스프링 트랜잭션은 `@Transactional`을 이용하여 손쉽게 처리할 수 있다.
    - 중간에 `RuntimeException`이 발생하면 자동으로 롤백하고, 정상 처리되면 커밋한다.
    - 데이터베이스 트랜잭션 한정이다. redis 트랜잭션은 별도의 트랜잭션 보장을 위한 객체가 필요할 수 있다.

## 도메인 이벤트 처리

- 도메인 영역에서 발생시킨 이벤트를 처리하는 것이다.
- 도메인의 상태변경을 이벤트로 처리할 수 있다.
    - e.g. 암호 변경됨, 주문 취소함
- 도메인에서 발생한 이벤트를 응용 서비스에서 받아 처리한다.
    - e.g. 암호 초기화 후 암호 초기화 이메일을 보낼 때, 변경된 암호를 발송하는 이벤트 핸들러를 등록한다.
- 이벤트를 사용하면 코드가 다소 복잡해지는 대신 도메인 간의 의존성이나 외부 시스템에 대한 의존도를 낮춰주는 장점이 있다.
- 시스템을 확장하는 데에 이벤트가 핵심 역할을 수행한다.

# 표현 영역

- 사용자가 시스템을 사용할 수 있는 (화면) 흐름을 제공하고 제어한다.
- 사용자의 요청 데이터를 응용 서비스가 요구하는 형식으로 변환하고, 응용 서비스의 결과를 사용자에게 응답할 수 있는 형식으로 반환한다.
- 사용자의 세션을 관리한다.

# 값 검증

- 표현 영역: 필수 값, 값의 형식, 범위 등을 검증
- 응용 서비스: 데이터의 존재 유무같은 논리적 오류 검증
- 응용 서비스에서 어디까지 검증할지 여부는 엄격성이 얼마나 필요하냐에 따라 다르다.
    - 응용 서비스를 실행하는 주체가 다양하면 응용 서비스에서도 값 검증이 필요할 수 있다.

# 권한 검사

- 사용자 A가 기능 F를 실행할 수 있는가?
- 시스템마다 권한 검사의 복잡도가 달라진다.
    - 관리자마다 사용할 수 있는 기능이 다른 경우
    - 실행할 수 있는 기능이 역할마다 달라지는 경우
- 다양한 상황을 충족하기 위해 스프링 시큐리티같은 프레임워크는 유연하고 확장 가능한 구조를 가진다. (=유연한만큼 복잡하다.)
- 서블릿 필터를 이용하여 컨트롤러를 거치기 전 URL별로 권한 검사를 할 수 있다.
- URL만으로 접근 제어를 할 수 없는 경우 응용 서비스의 메서드 단위로 권한 검사를 수행해야 한다.
- AOP를 활용하여 애노테이션으로 서비스 메서드에 대한 권한 검사를 할 수 있다.
    - `@PreAuthorize("hasRole('ADMIN')")`
- 개별 도메인 단위로 권한 검사를 해야 하는 경우는 구현이 복잡해진다.
    - e.g. 게시글 삭제는 작성자 본인 또는 관리자만 가능한 경우
    - 게시물을 로딩해야 권한 검사를 수행할 수 있다.
    - 스프링 시큐리티같은 보안 프레임워크를 사용하여 권한 검사 기능을 통합할 수도 있다.

# 조회 전용 기능과 응용 서비스

- 단순 조회만 하는 경우에는 트랜잭션도 필요없고, 추가적인 로직이 필요 없어 표현 영역에서 바로 조회 전용 기능을 사용해도 무방하다.