# Chapter 4. 레포지터리와 모델구현(JPA 중심)

- 객체 기반의 도메인 모델과 관계형 데이터 모델 간의 매핑을 처리하는 기술로 ORM 만한 것이 없다.
    - 대표적으로 자바 진영에서는 JPA가 있다
- DIP에 따라 레포지터리 구현 클래스는 인프라스트럭처 영역에 위치한다.
    - 레포지터리 인터페이스는 도메인
    - 레포지터리 구현 클래스는 `EntityManager`를 통해서 기능을 구현한다.

### 엔티티와 밸류를 매핑하기 위해선 어떻게 해야하는가?

- 애그리거트 루트는 엔티티이므로 `@Entity`로 매핑 설정한다.
- 한 테이블에 엔티티와 밸류 데이터가 같이 있다면 밸류는 `@Embeddable`로, 밸류 타입 프로퍼티는 `@Embedded`로 매핑 설정한다.

### 필드에서 설정한 이름과 DB 칼럼 이름이 다를 때는 어떻게 해야하는가?

- 필드에서 설정한 이름(`@Column`)와 매핑되는 칼럼이름이 다르면 `@AttributeOverrides`를 이용해 매핑할 칼럼 이름을 변경해줄 수 있다
- 예를 들어, `Order`에 속하는 `Orderer`는 밸류인데 `Orderer`의 `memberId` 필드가 `MemberId` 타입으로 되어있다. `MemberId` 타입은 밸류로 `@Column(name = "member_id") private String id;` 를 가지고 있다. 이때 DB 칼럼은 `orderer_id`로 서로 다른 이름이라 `@AttributeOverrides`를 통해 이 둘을 매핑시켜줄 수 있다.

### 평소에 사용하던 필드 접근 방식을 사용하자

- JPA에서 매핑 처리 방식에는 필드 방식과 메서드 방식이 있다.
    - 필드 방식
        - `@Access(AccessType.FIELD)`를 붙임
        - get/set을 따로 만들지 않고 cancel, change 같은 기능 중심으로 구현하기 때문에 이 방법이 더 좋다.
    - 메서드 방식
        - `@Access(AccessType.PROPERTY)`를 붙이고 get/set 구현

> `@Id`나 `@EmbbededId`가 필드에 위치하면 필드방식, getter에 위치하면 메서드 방식으로 접근 방식을 결정한다. 우리는 `@Id` 를 항상 필드에 붙였는데 그래서 `@Access`를 따로 붙이지 않아도 자연스럽게 필드 접근 방식으로 된 거 같다.

### 밸류 타입에서 두 개 이상의 필드를 하나의 DB 컬럼과 매핑하고 싶을 때는 어떻게?

- 두 개의 필드를 DB 테이블의 한 개 컬럼에 매핑하고 싶다면 `AttributeConverter`, `@Converter`, `@Convert`를 사용하면 된다.
- 예를 들어, class Length에 value, unit 필드가 있을 때 이를 width라는 하나의 컬럼으로 저장하고 싶은 경우가 있다.
- `convertToDatabaseColumn()`, `convertToEntityAttribute()`를 구현하면 된다.

### 밸류 컬렉션을 DB에 저장하려면?

두 가지 방법이 있다

- 밸류 컬렉션을 별도 테이블로 저장
    - 밸류 컬렉션을 별도 테이블로 매핑할 때는 `@ElementCollection`과 `@CollectionTable`을 함께 사용한다.
    - `@OrderColumn` 을 이용해서 지정한 칼럼에 인덱스 값을 저장할 수 있다.
- 밸류 컬렉션을 콤마로 구분해 한 개의 컬럼에 저장
    - `AttributeConverter`를 사용해서 하면 된다.

### 밸류 타입을 식별자로 하려면?

- 해당 엔티티의 밸류 타입(식별자)에 `@EmbeddedId`를 설정한다.
- 밸류 타입을 식별자로 만들면 밸류 타입 자체에 로직을 구현할 수 있게 된다.
    - 시스템 세대를 구분하는 로직을 넣는다던지 할 수 있다.
- JPA에서 식별자 타입은 `Serializable` 타입이어야 한다.

### 엔티티가 해당 애그리거트에 속하는 지 잘 판단하자

- 상품 애그리거트에 고객 리뷰가 포함된다고 상품 애그리거트에 고객 엔티티를 포함시키면 안된다.
- 리뷰의 변경이 상품에 영향을 주지 않으므로 둘의 라이프 사이클이 다르므로 상품 애그리거트, 리뷰 애그리거트로 나눠야 한다.

### 하나의 엔티티에 다수 테이블을 매핑하고 싶다면?

- `@SecondaryTables`를 사용하면 된다. 해당 어노테이션을 사용하면 항상 조인해서 가져오기 때문에 지연 로딩에는 맞지 않다.
    - 또 여러 속성이 있다면 `@AttributeOverride`를 사용하면 된다.

### 계층 구조를 갖는 밸류 타입을 구현해야 한다면?

- `@Embeddable` 타입으로는 안되고 `@Entity`를 이용한 상속 매핑(`@Inheritance`)으로 처리해야 한다.
    - 밸류 타입을 엔티티로 처리해야하므로 식별자 매핑을 추가해야 하고, 상속한 구현 클래스를 구분하기 위해 식별 칼럼(`@DiscriminatorColumn`)을 추가해야 한다.
    - 상속 받은 클래스에는 식별칼럼에 따라 다르게 매핑하기 위해 `@DiscriminatorValue`를 설정해준다.
    - 타입에 따라 다른 기능을 구현하려면 어차피 if-else를 써야 한다.

### 애그리거트는 개념적으로 하나다?

- 애그리거트는 개념적으로 하나여야 하지만 그렇다고 애그리거트에 속한 객체를 모두 로딩해야된다는 건 아니다.
- 필요한 부분만 조회해서 갖고오는 LAZY 로딩 전략으로 만들자.
