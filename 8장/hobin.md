# Chapter 8. 애그리거트 트랜잭션 관리

- 한 애그리거트를 두 사용자가 거의 동시에 변경할 때 트랜잭션이 필요하다
    - 어드민에서 주문 애그리거트의 배송 상태를 변경함과 동시에 유저가 주문 애그리거트의 배송지를 변경한다면!?
    - 고객이 원하지 않은 다른 배송지에 배송이 갈 수 있기 때문
- 이런 상황에서는 트랜잭션이 필요하며 아래와 같은 애그리거트 트랜잭션 처리 방법이 필요하다.
    - 선점 잠금
    - 비선점 잠금
    - 오프라인 선점 잠금

## 선점 잠금(Pessimistic Lock)

- **하나의 트랜잭션 범위 안에서** 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하는 것을 막는 방식
- 즉, 다른 쪽이 잠금되어있다면 블로킹되어 아무것도 못 한다. (대기 상태가 된다)
    - 트랜잭션을 커밋하면 잠금을 해제한다
- 보통 DBMS가 제공하는 행 단위 잠금을 사용해서 구현한다. `for update` 쿼리를 사용한다.
- JPA의 경우, `LockModeType`을 통해 구현할 수 있다. (`for update` 쿼리가 날라간다)
    - `entityManager.find(Order.class, orderNo, LockModeType.PESSIMISTIC_WRITE)`
    - 조회를 먼저 한 후, update를 하기 때문에 select 시점에 for update를 해서 lock을 걸어야 한다.
- 선점 잠금을 구현할 때 교착상태(데드락, 서로의 자원을 가지고 있으면서 원하는 상태)가 발생할 수 있다.
    - 사용자 수가 많을 때 발생할 가능성이 높으며 교착 상태에 빠지는 스레드가 점점 더 많아지게 된다.
    - 이런 문제가 발생하지 않도록 잠금을 구할 때 최대 대기 시간을 지정해야 한다.
        - `javax.persistence.lock.timeout`
        - 지정한 시간 내에 잠금을 구하지 못하면 예외가 발생한다.

> 다른 스레드의 수정을 아예 블로킹하는 방식

## 비선점 잠금(Optimistic Lock)

- 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식
- 버전으로 숫자 타입의 프로퍼티를 추가해야 함
- 즉, 애그리거트를 수정할 때마다 트랜잭션을 커밋할 때마다 버전을 1씩 올림
- 버전 값이 현재 버전과 동일한 경우에만 데이터를 수정
- JPA에서는 @Version을 사용하면 된다.
- `OptimisticLockingFailureException`을 체크하면 된다.
- **버전을 애그리거트와 같이 전송**하기 때문에 트랜잭션을 확장할 수 있다.
    - `if(!order.matchVersion(req.getVersion());` 으로 간단히 구현해서 버전 체크를 하자.
- 애그리거트 루트 기준으로 판단하기 때문에 루트가 아닌 내부 엔티티의 값만 변경된다면 루트 엔티티는 바뀌지 않았다고 판단하여 버전 값을 갱신하지 않는다.
    - JPA는 이런 상황을 방지하기 위해 find()할 때 강제로 버전 값을 증가시키는 잠금모드를 지원한다
        - `entityManager.find(Order.class, id, LockModeType.OPTIMISTIC_FORCE_INCREMENT);`

> 나중에 버전을 확인해서 충돌을 확인하는 방식

## 오프라인 선점 잠금

- 여러 트랜잭션에 걸쳐 동시 변경을 막는다.
    - 첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제한다.
- 오프라인 잠금을 선점하고 프로그램을 종료하면 잠금을 해제하지 않으므로 다른 사용자는 영원히 잠금을 구할 수 없게 된다.
- 그래서 오프라인 선점 방식은 잠금의 유효 시간을 가져야 한다.
    - 지속적으로 수정할 수 있도록 1분 단위로 Ajax 호출을 해서 잠금 유효 시간을 1분씩 증가시키기도 한다.
- 오프라인 선점 잠금은 잠금 선점 시도, 잠금 확인, 잠금 해제, 잠금 유효 시간 연장 기능을 제공해야 한다.
- MySQL을 통해서 LockManager를 구할 수 있다.

> 여러 트랜잭션이 있을 때 첫 번째 트랜잭션, 마지막 트랜잭션 단위로 묶어서 변경을 막는 방식

## 정리

- 선점 잠금 → DB
    - 하나의 트랜잭션, 하나의 스레드
- 비선점 잠금 → 서버
    - 버전업
- 오프라인 선점 → 클라이언트, 서버
    - 여러 개의 트랜잭션
    - 비즈니스 관점으로의 전체 락
