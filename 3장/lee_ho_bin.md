# Chapter 3. 애그리거트

- 상위 수준의 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해하는데 도움이 된다
    - 주문 → 상품, 결제, 회원 등...
- 애그리거트는 관련된 객체를 하나의 군으로 묶어준다
- 일관성을 관리하는 기준이 되어 복잡한 도메인은 단순한 구조로 만들어준다
- 애그리거트는 경계를 갖는다. 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 오직 자기 자신만 관리한다
    - 주문 애그리거트는 배송지를 변경하거나 주문 상품 개수를 변경하나 회원의 비밀번호를 변경하거나 하진 않는다.
    - 함께 생성되는 구성 요소는 한 애그리거트에 속할 확률이 높다.
    - 주문할 상품 개수, 배송지 정보, 주문자 정보는 주문 시점에 함께 생성되므로 한 애그리거트에 속한다
    - Product와 Review는 한 애그리거트에 속하지 않는다. Product를 변경하는 주체가 상품 담당자라면 Review를 변경하는 주체는 고객이기 때문. 또한 Review의 변경이 Product에 영향을 주지 않는다
- 도메인 규칙을 제대로 이해할수록 실제 애그리거트의 크기는 줄어든다. 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많다
- 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이어서는 안 된다. OrderLine안에 있는 개별 구매 상품(quantity와 금액인 price)이 바뀌면 Order에 있는 총 금액도 바뀐다.

## 도메인 규칙과 일관성

- 단순히 필드를 변경하는 set 메서드는 가급적 피하자
    - 새로운 객체를 할당해서 값을 변경하자

    ```java
    private void setShippingInfo(ShippingInfo newShippingInfo) {
        this.shippingInfo = newShippingInfo;
    }
    ```

- value 타입은 불변으로 구현한다
- 단순히 바꾸는 기능만 하지 않도록 조심하자. 예를 들어, OrderLines만 바꾸게 된다면 Order의 totalAmounts값이 OrderLines와 일치하지 않게 된다. OrderLines와 함께 변경되는 값이 있으니 조심하자. → 그러니 더더욱 외부에서 변경할 수 없도록 불변으로 만들자.

## 트랜잭션 범위

- 트랜잭션 범위는 작을수록 좋다
    - 잠금 대상이 더 적어지니까 성능적으로 더 좋다
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.
    - 다른 애그리거트를 변경하지 않는다
    - 변경하면 애그리거트 간 결합도가 높아진다
    - 어쩔 수 없이 수정해야된다면 직접 수정하지말고 응용 서비스에서 애그리거트를 수정하도록 하자.

## 레포지터리와 애그리거트

- 객체의 영속성을 처리하는 레포지터리는 애그리거트 단위로 존재한다
- Order가 애그리거트 루트이고 OrderLine인 애그리거트에 속하는 구성요소이므로 Order를 위한 레포지터리만 존재한다.
- 애그리거트는 개념적으로 하나이므로 레포지터리는 애그리거트 전체를 저장소에 영속화해야한다. Order 애그리거트와 관련된 테이블이 세 개라면 레포지토리를 통해서 Order뿐만 아니라 구성요소 모두 영속화해야한다.
    - Order 애그리거트 전체를 영속화해야한다.

## ID를 이용한 애그리거트 참조, 조회 성능

- ORM을 사용하면 다른 애그리거트로 객체 참조를 쉽게 할 수 있어 다른 애그리거트의 상태를 쉽게 바꿀 수 있다. 이 부분을 로직으로 만들면 결합도가 증가하기 때문에 결과적으로는 좋지 않다
- JPA에서 애그리거트의 상태를 변경하는 기능을 실행하는 경우에는 불필요한 객체를 함께 로딩할 필요가 없으므로 지연 로딩이 유리하다.
- 하위 도메인 마다 다른 DB를 사용하면 다른 애그리거트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없다.
- ID 참조를 사용하면 어느정도 해결이 가능하다
    - 이는 애그리거트의 경계를 명확히 하고 한 애그리거트에 속한 객체들만 참조로 연결된다. 애그리거트 간 물리적인 연결도 제거해서 모델의 복잡도를 낮춰준다.

    ```java
    Customer customer = customerRespository.findById(order.getOrderer().getCustomerId());
    ```

- 항상 ID 참조를 통해 가져와야하기 때문에 JPA처럼 N + 1문제가 발생한다. 주문 1개 안에 주문 개수가 10개면 조인해서 가져와도 되는데 항상 ID 참조라서 쿼리가 11번 나간다.
    - 이걸 해결하려면 데이터 조회를 위한 별도 조회 쿼리를 만들면 된다.

## 애그리거트 간 집합 연관

- 1 : N 관계에서 페이징이 적용되면 굳이 N쪽을 모두 조회할 필요없음에도 불구하고 모두 조회하게 된다.
    - 1이 카테고리, N이 상품이라고 한다면 Product에 CategoryId라는 필드를 추가해 알 수 있다.
    - productRepository.findByCategoryId(category.getId())가 된다.
- M : N 관계는 양쪽 애그리거트에 컬렉션으로 연관을 만든다.
    - 조인 테이블을 사용해 구현할 수 있다.

## 애그리거트를 팩토리로 사용하기

- Product를 생성 가능한지 판단하는 코드와 Product를 생성하는 코드가 모두 RegisterProductService 안에 있다.
- 생성 여부를 판단하고 생성하는 코드는 팩토리 클래스로 만들 수 있다.
- Store라는 애그리거트를 만들어서 생성하는 담당으로 만들 수 있다. 생성 가능 여부는 Store에 만들면 된다.
